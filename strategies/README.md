# Strategies

There are two types of strategies:

1. **Action:**  
   These strategies are trivial in nature and are very basic & simple.

2. **Rational:**  
   These strategies incorporate a degree of rationality by processing various game metrics before deciding on a move.

## Rational Strategies

### Strategy.py

This is the core object that gives a strategy its rational character. When a decision is to be made, the strategy takes in the current game information, processes several metrics, and ultimately decides on a move (for example, a frugal move or a prodigal move). Below is an outline of how it works:

1. **Factoring in Basic Information:**  
   When the `decide` function is called with a non-empty information dictionary, the following data is internalized as class attributes:
   - **Seed:** A seed value for random functions.
   - **Hole Cards & Community Cards:** The cards dealt to the player and those on the board.
   - **Round:** The current round of the game.
   - **Big Blind:** The value of the big blind (used for calculating pot limits and converting bet sizes).
   - **Call Value:** The amount required to call.
   - **PlayerBetAmt:** The total amount the player has bet so far in the hand.
   - **Pot:** The current pot size.

2. **Setting the Initial Pot:**  
   The method `setInitialPot()` calculates the initial pot value:
   - **If `round == 0`:**  
     The initial pot is set to twice the big blind (representing 1 small blind + 1 big blind for heads-up games).
   - **If `round != 0`:**  
     The initial pot is not recalculated (and remains at its default value, typically –1) since this calculation is only used for pre-flop rounds.

3. **Setting the Round Limiter:**  
   After reading the game information:
   - If it is the pre-flop round (`round == 0`) and `iniLimitMultiplier` is set (i.e. greater than 0), the maximum limit (`limit`) is set to `iniLimitMultiplier * initialPot`.
   - Otherwise, a default limit (`defaultLimit`) is used.

4. **Reasoning the Decision:**  
   The `reason()` method computes key metrics used in decision making:
   - **Hand Strength (`hs`):**  
     Calculated using the `privateValue` function (rounded to six decimal places).
   - **Bluffing:**  
     If the `bluff` flag is active (i.e. greater than 0) and `hs < 0.5`, a random chance may invert the hand strength via the `bluffer()` method.
   - **Potential (`sp`):**  
     Determined by the `potential` function when in rounds 1 or 2; otherwise set to 0.
   - **Pot Odds (`ps`):**  
     Computed as the ratio of the call value to the pot.
   - **Upper Limits (`ul_` and `ul`):**  
     - `ul_` is computed as either `(sp + risk)` for rounds 1 and 2 or `(hs + risk)` otherwise.
     - `mu` is computed as `(hs + shift)`.
     - The final upper limit (`ul`) is the maximum of `ul_` and `mu`.
   - **Maximum Bet (`max_bet`):**  
     Calculated as `ul * pot` (rounded appropriately).

   (Note: The lower limit `ll` is set to `0` by default and is used in subsequent bet calculations.)

5. **Determining the Bet Size:**  
   The `setBet()` method uses the metrics computed earlier to decide on a bet:
   - If `ul` is different from `ll` (with `ll` defaulting to 0), the odds `r` are calculated by calling the `odds` function with `(ll, ul, mu)`.
   - If these odds (`r`) are less than the pot odds (`ps`), the strategy is deemed "out of money" and sets the bet amount (`betAmt`) to -1 (indicating a check or fold).
   - Otherwise, the monetary value is set as `pot * r` and the bet amount is capped by `max_bet`.

6. **Limiting the Bet Amount:**  
   The `limiter()` method ensures that the bet amount does not exceed the overall limit:
   - For a bet amount other than –1 or 0, it calculates the total current bet (`tcb = betAmt + playerBetAmt`).
   - If `tcb` exceeds `limit`, the bet is adjusted to `limit - playerBetAmt`.

7. **Converting Bet Amount to Blinds:**  
   The `toBlinds()` method adjusts the bet amount so that it aligns with multiples of the big blind:
   - If the bet amount is not in a check/fold/call scenario (i.e. not –1 or 0), the excess over the call value is rounded to the nearest multiple of the big blind.
   - The bet amount is then re-adjusted accordingly.

8. **Setting the Final Move:**  
   Finally, the `setMove()` method determines the move to be made:
   - **Check/Fold:**  
     If `betAmt` is –1, the move is set to either a check (if `callValue` is 0) or a fold.
   - **Frugal Move:**  
     If `betAmt` is 0 or exactly equal to `callValue`, a frugal move is generated by calling `frugalMove()`.
   - **Prodigal Move:**  
     If `betAmt` is greater than `callValue`, a prodigal move is generated via `prodigalMove()`, using the excess bet amount.
   - In rare scenarios where `betAmt` is less than `callValue`, the strategy defaults to folding.

9. **The `decide()` Method:**  
   When the strategy is used in evaluation mode (`eval` is `True`), the `decide()` method:
   - Calls `initialise()` with the provided game information.
   - Processes the information (via the methods described above) to determine the move.
   - Optionally logs metrics via an `inspector` if one is attached.
   - Returns the computed move.
   
   If `eval` is `False`, it raises a `NotImplementedError`, indicating that the strategy is meant to be overridden by subclasses.

---

### Additional Notes

- **Modules & Functions:**  
  This strategy uses helper functions (such as `privateValue`, `potential`, `odds`, `frugalMove`, and `prodigalMove`) imported from the `poker_metrics` package. These functions supply critical game metrics and standardized moves.

- **Customization:**  
  Attributes such as `shift`, `risk`, `bluff`, and `iniLimitMultiplier` can be adjusted (or overridden by subclasses) to alter the strategy’s aggressiveness or frugality.

- **Error Handling:**  
  A safeguard in `initialise()` raises an exception if the computed bet amount exceeds the allowed limit, ensuring consistency in the strategy's behavior.

This structure provides a robust framework for developing rational poker strategies by sequentially processing game information and making decisions based on well-defined metrics.